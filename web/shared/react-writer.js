// Generated by CoffeeScript 2.3.0
(function() {

var addClass, child, k, make, parseElement, props, raw, ref, v;

const React = require('react');

const update = require('react-addons-update');

// Parses a string like "tag#id.class1.class2" into its separate parts.
parseElement = function(str) {
  var classes, eatWord, id, tag;
  eatWord = function() {
    var dot, hash, word;
    hash = str.indexOf('#');
    dot = str.indexOf('.');
    if (hash === -1) {
      hash = 9999;
    }
    if (dot === -1) {
      dot = 9999;
    }
    word = str.slice(0, Math.min(hash, dot));
    str = str.slice(word.length);
    return word;
  };
  tag = eatWord() || 'div';
  classes = [];
  id = null;
  while (str !== '') {
    if (str[0] === '.') {
      str = str.slice(1);
      classes.push(eatWord());
    } else if (str[0] === '#') {
      str = str.slice(1);
      id = eatWord();
    } else {
      return false;
    }
  }
  return {tag, classes, id};
};

// an imperative layer (writer monad) over a functional layer (React) over an imperative layer (DOM manipulation) over a functional layer (HTML)...
// will move to jsx soon
make = function(fact, arg1, arg2) {
  var classes, factory, fn, id, me, prevParent, startProps, tag;
  if (arg1 != null) {
    if (typeof arg1 === 'function') {
      startProps = {};
      fn = arg1;
    } else {
      startProps = arg1;
      fn = arg2 != null ? arg2 : (function() {});
    }
  } else {
    startProps = {};
    fn = (function() {});
  }
  prevParent = window.theParent;
  if (typeof fact === 'string') {
    ({tag, classes, id} = parseElement(fact));
    factory = tag;
    startProps = update(startProps, {
      className: classes.length > 0 ? {
        $apply: function(oldClasses) {
          return `${oldClasses != null ? oldClasses : ''} ${classes.join(' ')}`;
        }
      } : {},
      id: id != null ? {
        $set: id
      } : {}
    });
  } else {
    factory = fact;
  }
  window.theParent = {
    props: startProps,
    children: []
  };
  fn();
  me = React.createElement(factory, window.theParent.props, ...window.theParent.children);
  window.theParent = prevParent;
  return me;
};

child = function(...args) {
  var me;
  me = make(...args);
  return window.theParent = update(window.theParent, {
    children: {
      $push: [me]
    }
  });
};

raw = function(...raws) {
  return window.theParent = update(window.theParent, {
    children: {
      $push: raws
    }
  });
};

props = function(obj) {
  return window.theParent = update(window.theParent, {
    props: {
      $merge: obj
    }
  });
};

addClass = function(...classes) {
  classes = [].concat.apply([], classes); // flatten into an array of strings
  return window.theParent = update(window.theParent, {
    props: {
      className: {
        $apply: function(oldClasses) {
          return `${oldClasses != null ? oldClasses : ''} ${classes.join(' ')}`;
        }
      }
    }
  });
};

ref = {make, child, raw, props, addClass};
for (k in ref) {
  v = ref[k];
  exports[k] = v;
}

}).call(this);
